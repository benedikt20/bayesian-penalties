---
title: "SDS 6540 Final Project"
author: "Benedikt Farag"
date: "`r Sys.Date()`"
format: 
  html:
    toc: true
    toc-depth: 5
    number-sections: true
    toc-expand: true    # replaces "toc_float"
    self-contained: true
  pdf:
    documentclass: article
    geometry: margin=1in
urlcolor: magenta
---
<!-- Render: system("quarto render multinomial_model.qmd --to pdf") -->

```{r}
library(dplyr)
library(brms)
library(ggplot2)
library(plotly)
library(tibble)
library(forcats) # For fct_reorder
word <- stringr::word

save_figs <- FALSE  # set to TRUE to save figures

# make figures directory to save figures
if (save_figs & !dir.exists("figures")) {
  dir.create("figures")
}

# make models directory to save models
if (!dir.exists("models")) {
  dir.create("models")
}
```

# Load data

```{r}
data <- read.csv("data/penalties_scraped_corrected.csv")

# remove rows with outcome as 'Wayward' (invalid penalties)
# example of wayward penalty:  
#       https://www.youtube.com/watch?v=AapiDn2E8I4 
data <- data %>%
  filter(outcome != "Wayward")


rpost <- 3.66     # left post x coordinate (m)
lpost <- -rpost   # right post x coordinate (m)
bar <- 2.44       # goal height (m)
delta = 0.12      # post thickness
Y_POINTS <- 100   # number of points along y axis
Z_POINTS <- 100   # number of points along z axis
```


```{r}
ggplot(data, aes(x = y_end, y = z_end, color = outcome)) +
  geom_point(alpha = 0.9, size=1) +
  geom_rect(
    xmin = lpost, xmax = rpost, ymin = 0, ymax = bar,
    fill = NA, color = "black", linewidth = 0.3
  ) +
  geom_rect(
    xmin = lpost - delta, xmax = rpost + delta, ymin = 0, ymax = bar + delta,
    fill = NA, color = "black", linewidth = 0.3
  ) +
  geom_segment(
    x = -5, y = 0, xend = 5, yend = 0,
    color = "black", linewidth = 0.3
  ) +
  theme_test() +
  coord_fixed(ratio = 1) +
  theme(
    legend.position = "top", legend.title = element_blank()
  )
if (save_figs){
  dev.copy2pdf(file = "figures/penalty_shot_locations.pdf", width=8, height=6)
}
```



```{r}
model_data <- data %>%
  mutate(outcome_simple = case_when(
    outcome == "Goal" ~ "Goal",
    outcome %in% c("Off T", "Post") ~ "Off T",
    outcome %in% c("Saved", "Saved to Post") ~ "Saved"
  )) %>%
  select(
    outcome_simple, y_end, z_end, goalkeeper, taker, minute, gender
  ) %>%
  na.omit()

# Convert all categorical predictors to factors
model_data$outcome_simple <- as.factor(model_data$outcome_simple)
model_data$gender <- as.factor(model_data$gender)
model_data$goalkeeper <- as.factor(model_data$goalkeeper)
model_data$taker <- as.factor(model_data$taker)
```

```{r}
# histogram for number of penalties per taker
taker_count <- model_data %>%
  group_by(taker) %>%
  summarise(total_penalties = n())
ggplot(taker_count, aes(x = total_penalties)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(
    title = "Distribution of Penalty Kicks per Taker",
    x = "Penalty kicks taken",
    y = "# Takers"
  ) 

# summary table of success ratios for takers
taker_goal_ratios <- model_data %>%
  group_by(taker) %>%
  summarise(
    total_penalties = n(),
    goals = sum(outcome_simple == "Goal"),
    goal_ratio = goals / total_penalties
  ) %>%
  arrange(desc(goal_ratio)) %>%
  filter(total_penalties >= 10) 
taker_goal_ratios
```


```{r} 

model_fit <- brm(
  outcome_simple ~ 
    t2(y_end, z_end) +  # 2D spline for location
    #s(minute) +         # 1D spline for game time
    #gender +            # Fixed effect for gender
    (1 | goalkeeper) +  # Random effect for goalkeeper
    (1 | taker),        # Random effect for taker
  
  data = model_data,
  family = categorical(link = "logit"), # Multinomial
  chains = 4,
  iter = 2500, 
  warmup = 1000,
  seed = 2025,
  file = "models/mn-model_keeper_taker.rds"
)

# print stan model
#stancode(model_fit)
```


# Posterior predictions over goal area

```{r}
# Goal grid for predictions
goal_grid <- expand.grid(
  y_end = seq(lpost, rpost, length.out = Y_POINTS), 
  z_end = seq(0, bar, length.out = Z_POINTS) 
)

# values for minute and gender if used
#goal_grid$minute <- 80  
#goal_grid$gender <- "female" 
```


```{r}
# posterior predictions for goal grid for all outcomes
posterior <- fitted(
  model_fit, 
  newdata = goal_grid,
  re_formula = NA      # marginalize over random effects
)

# combine posterior with the grid
surface_data <- as.data.frame(posterior) %>%
  bind_cols(goal_grid)
```


```{r}
# plot the 2D heatmap for P(Goal)
ggplot(surface_data, aes(x = y_end, y = z_end)) +
  geom_raster(aes(fill = `Estimate.P(Y = Goal)`)) + 
  scale_fill_gradientn(
    colours = c("blue", "cyan", "yellow", "red"),
    name = "P(goal)",
    limits = c(0, 1)
  ) +  
  # goal frame 
  geom_rect( 
    xmin = lpost, xmax = rpost, ymin = 0, ymax = bar, 
    fill = "transparent", 
    color = "black",
    linetype = "solid",
    size = 0.3
  ) +
  geom_rect(
    xmin = lpost - delta, xmax = rpost + delta, ymin = 0, ymax = bar + delta, 
    fill = "transparent", 
    color = "black",
    linetype = "solid",
    size = 0.3
  ) +
  geom_segment(
    x = -4, y = 0, xend = 4, yend = 0,
    color = "black",
    linetype = "solid",
    size = 0.3
  ) +
  labs(
    title = "Posterior for scoring a Goal",
    x = "y",
    y = "z"
  ) +
  scale_y_continuous(limits = c(0, bar + 2* delta), breaks = seq(0,bar+2*delta, by=0.5)) +
  theme_test() +
  coord_fixed(ratio = 1) 
if (save_figs){
  dev.copy2pdf(file = "figures/posterior_goal_heatmap.pdf", width=8, height=6)
}
```


```{r}
# reshape the 'Estimate.P(Y = Goal)' vector into a matrix
prob_matrix <- matrix(
  surface_data$`Estimate.P(Y = Goal)`, 
  nrow = Y_POINTS, 
  ncol = Z_POINTS
)

# 3d visualization of P(Goal) 
fig_3d <- plot_ly(
  x = ~unique(goal_grid$y_end),
  y = ~unique(goal_grid$z_end), 
  z = ~t(prob_matrix), # transpose
  type = "surface",
  colorscale = "Viridis",
  colorbar = list(title = "P(Goal)")
) %>%
  layout(
    title = "Posterior P(Goal)",
    scene = list(
      xaxis = list(title = "Horizontal (y_end)"),
      yaxis = list(title = "Vertical (z_end)"),
      zaxis = list(title = "P(Goal)", range = c(0, 1))
    )
  ) %>%
  # set axis limits
  layout(
    scene = list(
      xaxis = list(range = c(lpost + delta, rpost - delta)),
      yaxis = list(range = c(0, bar - delta)),
      zaxis = list(range = c(0, 1))
    )
  )

fig_3d
```


# Width of credible interval for P(Goal)

```{r}
# plot ggplot heatmap of CI width
ggplot(surface_data, aes(x = y_end, y = z_end)) +
  geom_raster(aes(fill = `Q97.5.P(Y = Goal)` - `Q2.5.P(Y = Goal)`)) +
  scale_fill_gradientn(
    colours = c("blue", "cyan", "yellow", "red"),
    name = "",
    limits = c(0, 0.305)
  ) +
  geom_rect(
    xmin = lpost, xmax = rpost, ymin = 0, ymax = bar,
    fill = NA, color = "black", size = 0.3
  ) +
  geom_rect(
    xmin = lpost - delta, xmax = rpost + delta, ymin = 0, ymax = bar + delta,
    fill = NA, color = "black", size = 0.3
  ) +
  geom_segment(
    x = -4, y = 0, xend = 4, yend = 0,
    color = "black", size = 0.3
  ) +
  labs(
    title = "Width of 95% CI for P(goal)",
    x = "y",
    y = "z"
  ) +
  theme_test() +
  scale_y_continuous(limits = c(0, bar + 2* delta), breaks = seq(0,bar+2*delta, by=0.5)) +
  coord_fixed(ratio = 1)
if (save_figs){
  dev.copy2pdf(file = "figures/ci_width_heatmap.pdf", width=8, height=6)
}
```

```{r}
# 3d plot of CI width

# reshape the CI vectors into matrices
q2_5_matrix <- matrix(
  surface_data$`Q2.5.P(Y = Goal)`,
  nrow = Y_POINTS, 
  ncol = Z_POINTS
)

q97_5_matrix <- matrix(
  surface_data$`Q97.5.P(Y = Goal)`,
  nrow = Y_POINTS, 
  ncol = Z_POINTS
)

# width of credible interval
diff <- q97_5_matrix - q2_5_matrix

# set greater than 0.3 to 0.3 for better visualization
diff[diff > 0.3] <- 0.3

# make a plotly
fig_3d <- plot_ly(
  x = ~unique(goal_grid$y_end),  
  y = ~unique(goal_grid$z_end),   
  z = ~t(diff), 
  type = "surface",
  colorscale = "Jet",
  colorbar = list(title = "CI Width")
) %>%
  layout(
    title = "Width of 95% Credible Interval for P(Goal)",
    scene = list(
      xaxis = list(title = "Horizontal Location (y_end)"),
      yaxis = list(title = "Vertical Location (z_end)"),
      zaxis = list(title = "P(Goal)")
    )
  ) %>%
  # set axis limits
  layout(
    scene = list(
      xaxis = list(range = c(lpost + delta, rpost - delta)),
      yaxis = list(range = c(0, bar - delta)),
      zaxis = list(range = c(0, 0.3))
    )
  )

fig_3d
```

Probability of scoring left vs right side, is it equal?

```{r}
# probability of scoring on the left side
left_side_prob <- surface_data %>%
  filter(y_end < 0) %>%
  summarise(mean_prob = mean(`Estimate.P(Y = Goal)`))
left_side_prob

# probability of scoring on the right side
right_side_prob <- surface_data %>%
  filter(y_end >= 0) %>%
  summarise(mean_prob = mean(`Estimate.P(Y = Goal)`))
right_side_prob

# probability of sign error? (like p-value for left vs right)...
```



# Analysis of specific players

```{r}
# random effects for takers
taker_ranef <- ranef(model_fit)$taker

# get saved and offT estimates (vs goal)
saved_effects <- as.data.frame(taker_ranef[, , "muSaved_Intercept"])
offT_effects <- as.data.frame(taker_ranef[, , "muOffT_Intercept"])

# takers penalty count
taker_counts <- model_data %>%
  count(taker, name = "num_penalties")

# add to df
takers_2d_df <- data.frame(
  taker = rownames(saved_effects),
  Est_Saved = saved_effects$Estimate,
  Est_OffT = offT_effects$Estimate,
  # You could also add Est.Error, Q2.5, etc. if you want
  Est_Saved_Error = saved_effects$Est.Error,
  Est_OffT_Error = offT_effects$Est.Error
) %>%
  left_join(taker_counts, by = "taker")

# find players that have off t odds bigger than 0.2 or less than -0.2:
high_offt <- takers_2d_df %>%
  filter(Est_OffT > 0.2 | Est_OffT < -0.2) %>%
  arrange(desc(Est_OffT))

# plot 2d taker ability: bottom left is best
ggplot(takers_2d_df, aes(x = Est_Saved, y = Est_OffT, label = taker)) +
  geom_point(aes(size= num_penalties), alpha = 0.4, color = "blue") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    #title = "Taker Ability in 2D",
    x = "Log-Odds Saved (vs. Goal)",
    y = "Log-Odds Off Target (vs. Goal)",
    size = "#Penalties"
  ) +
  # add outlier taker names to their points
  geom_text(data = high_offt, aes(label = word(taker, -2, -1), hjust = ifelse(Est_Saved < -0.01, 1.15, -0.15)), vjust = 0.2, size = 3) +
  theme_bw()
if (save_figs){
  dev.copy2pdf(file = "figures/taker_ability_2d.pdf", width=8, height=6)
}
```


# Player vs goalkeeper plots (extremes)

```{r}
# convert to a data frame and sort
taker_saved_df <- saved_effects %>%
  rownames_to_column("taker") %>%
  arrange(Estimate) # Sort in ascending order

# best takers (least likely to be saved)
print("Takers LEAST likely to be saved (vs. Goal):")
print(head(taker_saved_df, 5))

# worst takers (most likely to be saved)
print("Takers MOST likely to be saved (vs. Goal):")
print(tail(taker_saved_df, 5))
```

```{r}
# random effects for goalkeepers
gk_ranef <- ranef(model_fit)$goalkeeper

# estimate for "Saved vs. Goal"
gk_saved_effects <- gk_ranef[, , "muSaved_Intercept"]

# convert to a data frame and sort
gk_saved_df <- as.data.frame(gk_saved_effects) %>%
  rownames_to_column("goalkeeper") %>%
  arrange(desc(Estimate)) # descending order

# best goalkeepers (most likely to save)
print("Goalkeepers MOST likely to save (vs. Goal):")
print(head(gk_saved_df, 5))

# worst goalkeepers (least likely to save)
print("Goalkeepers LEAST likely to save (vs. Goal):")
print(tail(gk_saved_df, 5))
```


```{r}
# full keeper random effects
gk_saved_df <- as.data.frame(gk_ranef[, , "muSaved_Intercept"]) %>%
  rownames_to_column("goalkeeper")

# Find the top 10 and bottom 10
top_10_gk <- gk_saved_df %>% slice_max(n = 10, order_by = Estimate)
bottom_10_gk <- gk_saved_df %>% slice_min(n = 10, order_by = Estimate)
plot_data_gk <- bind_rows(top_10_gk, bottom_10_gk)

# random effects plot for goalkeepers: positive better than average 
ggplot(plot_data_gk, aes(x = Estimate, y = fct_reorder(goalkeeper, Estimate))) +
  geom_errorbarh(aes(xmin = Q2.5, xmax = Q97.5), height = 0.2) +
  geom_point(color = "blue") +
  
  # population average line
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  
  labs(
    title = "Goalkeeper Random Effects for saves",
    x = "Log-Odds Estimate (muSaved_Intercept)",
    y = "Goalkeeper"
  ) +
  theme_bw()
if (save_figs){
  dev.copy2pdf(file = "figures/goalkeeper_random_effects.pdf", width=8, height=6)
}
```


# best and worst takers plot (saved vs goal)

```{r}

# estimate for "Saved vs. Goal" for takers
taker_saved_df <- as.data.frame(taker_ranef[, , "muSaved_Intercept"]) %>%
  rownames_to_column("taker")

# top 10 and bottom 10 takers
best_10_takers <- taker_saved_df %>% slice_min(n = 10, order_by = Estimate)
worst_10_takers <- taker_saved_df %>% slice_max(n = 10, order_by = Estimate)
plot_data_taker <- bind_rows(best_10_takers, worst_10_takers)

# random effects plot for takers: negative better than average
ggplot(plot_data_taker, aes(x = Estimate, y = fct_reorder(taker, Estimate))) +
  geom_errorbarh(aes(xmin = Q2.5, xmax = Q97.5), height = 0.2) +
  geom_point(color = "darkgreen") +
  
  # population average line
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  
  labs(
    title = "Taker Random Effects for saves",
    x = "Log-Odds Estimate (muSaved_Intercept)",
    y = "Taker"
  ) +
  theme_bw()
if (save_figs){
  dev.copy2pdf(file = "figures/taker_random_effects.pdf", width=8, height=6)
}
```

# best taker vs worst keeper plot

```{r}

# best taker with lowest estimate (least likely to be saved)
best_taker_name <- taker_saved_df %>%
  slice_min(n = 1, order_by = Estimate) %>%
  pull(taker)

# worst keeper with lowest estimate (least likely to save)
worst_goalkeeper_name <- gk_saved_df %>%
  slice_min(n = 1, order_by = Estimate) %>%
  pull(goalkeeper)

print(paste("Best Taker (least likely to be saved):", best_taker_name))
print(paste("Worst Goalkeeper (least likely to save):", worst_goalkeeper_name))

# prediction grid for best taker vs worst goalkeeper
prediction_grid_wb <- expand.grid(
  y_end = seq(lpost, rpost, length.out = Y_POINTS), 
  z_end = seq(0, bar, length.out = Z_POINTS) 
)

prediction_grid_wb$taker <- best_taker_name
prediction_grid_wb$goalkeeper <- worst_goalkeeper_name

# get fitted values
posterior_matchup <- fitted(
  model_fit, 
  newdata = prediction_grid_wb
)

surface_data_matchup_wb <- as.data.frame(posterior_matchup) %>%
  bind_cols(prediction_grid_wb)
```


```{r}
ggplot(surface_data_matchup_wb, aes(x = y_end, y = z_end)) +
  geom_raster(aes(fill = `Estimate.P(Y = Goal)`)) + 
  scale_fill_gradientn(
    colours = c("blue", "cyan", "yellow", "red"),
    name = "P(Goal)",
    limits = c(0, 1)
  ) +
  
  # Goal frame
  geom_rect(
    xmin = lpost, xmax = rpost, ymin = 0, ymax = bar, 
    fill = "transparent", color = "black", linetype = "solid", size = 0.3
  ) +
  geom_rect(
    xmin = lpost - delta, xmax = rpost + delta, ymin = 0, ymax = bar + delta, 
    fill = "transparent", color = "black", linetype = "solid", size = 0.3
  ) +
  geom_segment(
    x = -4, y = 0, xend = 4, yend = 0,
    color = "black", linetype = "solid", size = 0.3
  ) +
  
  labs(
    title = "Posterior P(Goal): Best vs. Worst Matchup",
    subtitle = paste("Taker:", best_taker_name, "\nGoalkeeper:", worst_goalkeeper_name),
    x = "y",
    y = "z"
  ) +
  theme_test() +
  scale_y_continuous(limits = c(0, bar + 2* delta), breaks = seq(0,bar+2*delta, by=0.5)) +
  coord_fixed(ratio = 1)
if (save_figs){
  dev.copy2pdf(file = "figures/best_taker_worst_keeper_heatmap.pdf", width=8, height=6)
}

# probability of scoring for best taker vs worst keeper
mean(surface_data_matchup_wb$`Estimate.P(Y = Goal)`)
```

# best keeper vs worst taker plot

```{r}
# find best keeper
best_goalkeeper_name <- gk_saved_df %>%
  slice_max(n = 1, order_by = Estimate) %>%
  pull(goalkeeper)

# find worst taker
worst_taker_name <- taker_saved_df %>%
  slice_max(n = 1, order_by = Estimate) %>%
  pull(taker)
print(paste("Best Goalkeeper:", best_goalkeeper_name))
print(paste("Worst Taker:", worst_taker_name))

# prediction grid
prediction_grid_bw <- expand.grid(
  y_end = seq(lpost, rpost, length.out = Y_POINTS), 
  z_end = seq(0, bar, length.out = Z_POINTS) 
)

# add specific players
prediction_grid_bw$taker <- worst_taker_name
prediction_grid_bw$goalkeeper <- best_goalkeeper_name

# get fitted values
posterior_bw <- fitted(
  model_fit, 
  newdata = prediction_grid_bw
)

surface_data_bw <- as.data.frame(posterior_bw) %>%
  bind_cols(prediction_grid_bw)
```


```{r}
# plot heatmap
ggplot(surface_data_bw, aes(x = y_end, y = z_end)) +
  geom_raster(aes(fill = `Estimate.P(Y = Goal)`)) + 
  scale_fill_gradientn(
    colours = c("blue", "cyan", "yellow", "red"),
    name = "P(Goal)",
    limits = c(0, 1)
  ) +
  
  # Goal frame
  geom_rect(
    xmin = lpost, xmax = rpost, ymin = 0, ymax = bar, 
    fill = "transparent", color = "black", linetype = "solid", size = 0.3
  ) +
  geom_rect(
    xmin = lpost - delta, xmax = rpost + delta, ymin = 0, ymax = bar + delta, 
    fill = "transparent", color = "black", linetype = "solid", size = 0.3
  ) +
  geom_segment(
    x = -4, y = 0, xend = 4, yend = 0,
    color = "black", linetype = "solid", size = 0.3
  ) +
  
  labs(
    title = "Posterior P(Goal): Worst vs. Best Matchup",
    subtitle = paste("Taker:", worst_taker_name, "\nGoalkeeper:", best_goalkeeper_name),
    x = "y",
    y = "z"
  ) +
  theme_test() +
  scale_y_continuous(limits = c(0, bar + 2* delta), breaks = seq(0,bar+2*delta, by=0.5)) +
  coord_fixed(ratio = 1)
if (save_figs){
  dev.copy2pdf(file = "figures/worst_taker_best_keeper_heatmap.pdf", width=8, height=6)
}

# probability of scoring for worst taker vs best keeper
mean(surface_data_bw$`Estimate.P(Y = Goal)`)
```

